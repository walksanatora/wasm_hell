// @flow
/* eslint no-unused-vars: off */

// THIS FILE IS AUTOGENERATED
// see scripts/generateTypeDefinitions.js
type Node =
  | Module
  | ModuleMetadata
  | ModuleNameMetadata
  | FunctionNameMetadata
  | LocalNameMetadata
  | BinaryModule
  | QuoteModule
  | SectionMetadata
  | LoopInstruction
  | Instr
  | IfInstruction
  | StringLiteral
  | NumberLiteral
  | LongNumberLiteral
  | FloatLiteral
  | Elem
  | IndexInFuncSection
  | ValtypeLiteral
  | TypeInstruction
  | Start
  | GlobalType
  | LeadingComment
  | BlockComment
  | Data
  | Global
  | Table
  | Memory
  | FuncImportDescr
  | ModuleImport
  | ModuleExportDescr
  | ModuleExport
  | Limit
  | Signature
  | Program
  | Identifier
  | BlockInstruction
  | CallInstruction
  | CallIndirectInstruction
  | ByteArray
  | Func;

type Block = LoopInstruction | BlockInstruction | Func;

type Instruction =
  | LoopInstruction
  | Instr
  | IfInstruction
  | TypeInstruction
  | BlockInstruction
  | CallInstruction
  | CallIndirectInstruction;

type Expression =
  | Instr
  | StringLiteral
  | NumberLiteral
  | LongNumberLiteral
  | FloatLiteral
  | ValtypeLiteral
  | Identifier;

type NumericLiteral = NumberLiteral | LongNumberLiteral | FloatLiteral;

type ImportDescr = GlobalType | Table | Memory | FuncImportDescr;

interface Module extends BaseNode {
  type: "Module",
  id?: string,
  fields: Array<Node>,
  metadata?: ModuleMetadata
}

interface ModuleMetadata extends BaseNode {
  type: "ModuleMetadata",
  sections: Array<SectionMetadata>,
  functionNames?: Array<FunctionNameMetadata>,
  localNames?: Array<ModuleMetadata>
}

interface ModuleNameMetadata extends BaseNode {
  type: "ModuleNameMetadata",
  value: string
}

interface FunctionNameMetadata extends BaseNode {
  type: "FunctionNameMetadata",
  value: string,
  index: number
}

interface LocalNameMetadata extends BaseNode {
  type: "LocalNameMetadata",
  value: string,
  localIndex: number,
  functionIndex: number
}

interface BinaryModule extends BaseNode {
  type: "BinaryModule",
  id?: string,
  blob: Array<string>
}

interface QuoteModule extends BaseNode {
  type: "QuoteModule",
  id?: string,
  string: Array<string>
}

interface SectionMetadata extends BaseNode {
  type: "SectionMetadata",
  section: SectionName,
  startOffset: number,
  size: NumberLiteral,
  vectorOfSize: NumberLiteral
}

interface LoopInstruction extends BaseNode {
  type: "LoopInstruction",
  id: string,
  label?: Identifier,
  resulttype?: Valtype,
  instr: Array<Instruction>
}

interface Instr extends BaseNode {
  type: "Instr",
  id: string,
  object?: Valtype,
  args: Array<Expression>,
  namedArgs?: Object
}

interface IfInstruction extends BaseNode {
  type: "IfInstruction",
  id: string,
  testLabel: Identifier,
  test: Array<Instruction>,
  result?: Valtype,
  consequent: Array<Instruction>,
  alternate: Array<Instruction>
}

interface StringLiteral extends BaseNode {
  type: "StringLiteral",
  value: string
}

interface NumberLiteral extends BaseNode {
  type: "NumberLiteral",
  value: number,
  raw: string,
  inf?: boolean,
  nan?: boolean
}

interface LongNumberLiteral extends BaseNode {
  type: "LongNumberLiteral",
  value: LongNumber,
  raw: string
}

interface FloatLiteral extends BaseNode {
  type: "FloatLiteral",
  value: number,
  nan?: boolean,
  inf?: boolean,
  raw: string
}

interface Elem extends BaseNode {
  type: "Elem",
  table: Index,
  offset: Array<Instruction>,
  funcs: Array<Index>
}

interface IndexInFuncSection extends BaseNode {
  type: "IndexInFuncSection",
  index: Index
}

interface ValtypeLiteral extends BaseNode {
  type: "ValtypeLiteral",
  name: Valtype
}

interface TypeInstruction extends BaseNode {
  type: "TypeInstruction",
  id?: Index,
  functype: Signature
}

interface Start extends BaseNode {
  type: "Start",
  index: Index
}

interface GlobalType extends BaseNode {
  type: "GlobalType",
  valtype: Valtype,
  mutability: Mutability
}

interface LeadingComment extends BaseNode {
  type: "LeadingComment",
  value: string
}

interface BlockComment extends BaseNode {
  type: "BlockComment",
  value: string
}

interface Data extends BaseNode {
  type: "Data",
  memoryIndex: Memidx,
  offset: Instruction,
  init: ByteArray
}

interface Global extends BaseNode {
  type: "Global",
  globalType: GlobalType,
  init: Array<Instruction>,
  name?: Identifier
}

interface Table extends BaseNode {
  type: "Table",
  elementType: TableElementType,
  limits: Limit,
  name?: Identifier,
  elements?: Array<Index>
}

interface Memory extends BaseNode {
  type: "Memory",
  limits: Limit,
  id?: Index
}

interface FuncImportDescr extends BaseNode {
  type: "FuncImportDescr",
  id: Identifier,
  signature: Signature
}

interface ModuleImport extends BaseNode {
  type: "ModuleImport",
  module: string,
  name: string,
  descr: ImportDescr
}

interface ModuleExportDescr extends BaseNode {
  type: "ModuleExportDescr",
  exportType: ExportDescrType,
  id: Index
}

interface ModuleExport extends BaseNode {
  type: "ModuleExport",
  name: string,
  descr: ModuleExportDescr
}

interface Limit extends BaseNode {
  type: "Limit",
  min: number,
  max?: number
}

interface Signature extends BaseNode {
  type: "Signature",
  params: Array<FuncParam>,
  results: Array<Valtype>
}

interface Program extends BaseNode {
  type: "Program",
  body: Array<Node>
}

interface Identifier extends BaseNode {
  type: "Identifier",
  value: string,
  raw?: string,
}

interface BlockInstruction extends BaseNode {
  type: "BlockInstruction",
  id: string,
  label?: Identifier,
  instr: Array<Instruction>,
  result?: Valtype
}

interface CallInstruction extends BaseNode {
  type: "CallInstruction",
  id: string,
  index: Index,
  numeric: Index,
  instrArgs?: Array<Expression>
}

interface CallIndirectInstruction extends BaseNode {
  type: "CallIndirectInstruction",
  id: string,
  signature: SignatureOrTypeRef,
  intrs?: Array<Expression>
}

interface ByteArray extends BaseNode {
  type: "ByteArray",
  values: Array<Byte>
}

interface Func extends BaseNode {
  type: "Func",
  name?: Index,
  signature: SignatureOrTypeRef,
  body: Array<Instruction>,
  isExternal?: boolean,
  metadata?: FuncMetadata
}
