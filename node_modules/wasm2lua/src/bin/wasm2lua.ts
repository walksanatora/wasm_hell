#!/usr/bin/env node

import "../patches"

import * as program from "commander"
import * as fs from "fs"
import * as fsExtra from "fs-extra"
import * as path from "path"
import { wasm2lua, WASM2LuaOptions } from "..";
import { scrypt } from "crypto";

let infile,outfile;

let manifest = JSON.parse(fs.readFileSync(__dirname + "/../../package.json").toString());

program.version(manifest.version)
    .arguments("<in.wasm> <out.lua>")
    .option("--heapBase <__GLOBALS__[0]>","Specify custom `heapBase` symbol name")
    .option("--freeName <free>","Specify custom `free` symbol name")
    .option("--nolibc","Assumes libc is absent and therefore ignores malloc/free")
    .option("--mallocName <malloc>","Specify custom `malloc` symbol name")
    .option("--pureLua","Compiles without using `ffi`")
    .option("-m, --minify <n>","Generates a minified Lua file (levels go from 0 to 3)")
    .option("--discardExportSymbols","Enhances minification by discarding symbols of exported functions")
    .option("-b, --bindings <bindings.idl>","Generates Lua-WebIDL bindings from the specified file")
    .option("--libmode","Adds a dummy main function to use this as a library (for WASI)")
    .option("--jmpstreamThreshold <n>","Specify jump size of n(opcodes) as the threshold for enabling jmpstream")
    .option("--maxPhantomNesting <n>","Specify maximum possible nesting of expressions folded via phantom registers")
    .action(function (inf, outf) {
        if((typeof inf === "string") && (typeof outf === "string")) {
            if((inf.trim() !== "") && (outf.trim() !== "")) {
                infile = path.resolve(inf.trim());
                outfile = path.resolve(outf.trim());
            }
        }
    })
    .parse(process.argv);

if((typeof infile === "undefined") || (typeof outfile === "undefined")) {
    program.outputHelp();
    process.exit(-1);
}

if(!fs.existsSync(infile)) {
    console.error(`Could not find input file ${infile}`);
}

fsExtra.ensureDirSync(path.dirname(outfile));

let conf: WASM2LuaOptions = {

};

if(program.bindings) {
    conf.webidl = {
        idlFilePath: program.bindings,
        nolibc: false,
    }
}

if(program.bindings && program.nolibc) {
    conf.webidl.nolibc = true;
}

if(program.bindings && program.mallocName) {
    conf.webidl.mallocName = program.mallocName;
}

if(program.bindings && program.freeName) {
    conf.webidl.freeName = program.freeName;
}

if(program.heapBase) {
    conf.heapBase = program.heapBase;
}

if(program.pureLua) {
    conf.pureLua = program.pureLua;
}

if(program.libmode) {
    conf.libMode = program.libmode;
}

if(program.jmpstreamThreshold) {
    conf.jmpStreamThreshold = parseInt(program.jmpstreamThreshold);
    if(!conf.jmpStreamThreshold || isNaN(conf.jmpStreamThreshold)) {
        conf.jmpStreamThreshold = null;
    }
}

if(program.maxPhantomNesting) {
    conf.maxPhantomNesting = parseInt(program.maxPhantomNesting);
    if(!conf.maxPhantomNesting || isNaN(conf.maxPhantomNesting)) {
        conf.maxPhantomNesting = null;
    }
}

if(program.minify) {
    conf.minify = Math.min(Math.max(parseInt(program.minify || 0),0),2) as (0 | 1 | 2 | 3);
    if(isNaN(conf.minify)) {
        conf.minify = null;
    }
}

let inst = new wasm2lua(fs.readFileSync(infile),conf)

if(program.minify) {
    let src = inst.outBuf.join("");
    src = require("luamin").minify(src);
    fs.writeFileSync(outfile,src);
}
else {
    fs.writeFileSync(outfile,inst.outBuf.join(""));
}
